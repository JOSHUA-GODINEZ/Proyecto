class Fruit {

    virtual void draw(sf::RenderWindow& win) { win.draw(sprite); }
    virtual void onMatch(Board* board, int row, int col) { /* default no extra effect */ }


    // start move to pixel coords in duration_ms milliseconds
    void startMoveTo(float tx, float ty, float duration_ms) {
        moveStart = sprite.getPosition();
        moveEnd = { tx, ty };
        moveDurationMs = duration_ms;
        moveClock.restart();
        moving = true;
    }

    void updateMove() {
        if (!moving) return;
        float elapsed = moveClock.getElapsedTime().asMilliseconds();
        if (moveDurationMs <= 0.f) {
            sprite.setPosition(moveEnd);
            moving = false;
            return;
        }
        float t = elapsed / moveDurationMs;
        if (t >= 1.f) {
            sprite.setPosition(moveEnd);
            moving = false;
        }
        else {
            sf::Vector2f p = moveStart + (moveEnd - moveStart) * t;
            sprite.setPosition(p);
        }
    }

    void startPop(float duration_ms = 220.f, float targetScale = 1.5f) {
        popActive = true;
        popElapsedMs = 0.f;
        popDurationMs = std::max(1.0f, duration_ms);
        popStartScale = sprite.getScale().x; // asumimos x==y
        popTargetScale = targetScale;
        pendingRemoval = true;
    }

    bool updatePop(float deltaMs) {
        if (!popActive) return false;
        popElapsedMs += deltaMs;
        float t = popElapsedMs / popDurationMs;
        if (t >= 1.f) t = 1.f;

        // easing: ease-out quad (mejor sensación)
        float e = 1.f - (1.f - t) * (1.f - t);
        float newScale = popStartScale + (popTargetScale - popStartScale) * e;
        sprite.setScale(newScale, newScale);

        if (t >= 1.f) {
            popActive = false;
            return true; // terminó
        }
        return false; // aún en progreso
    }

    bool isPopActive() const { return popActive; }

    bool isMoving() const { return moving; }

};

class NormalFruit : public Fruit {
public:
    NormalFruit(sf::Texture& tex, sf::Vector2f pos, int t) : Fruit(tex, pos, t) {}
    void onMatch(Board*, int, int) override {

    }
};

class BombFruit : public Fruit {
public:
    BombFruit(sf::Texture& tex, sf::Vector2f pos, int t) : Fruit(tex, pos, t) {}
    void onMatch(Board* board, int row, int col) override;
};

class IceFruit : public Fruit {
public:
    IceFruit(sf::Texture& tex, sf::Vector2f pos, int t) : Fruit(tex, pos, t) {}
    void onMatch(Board*, int, int) override {

    }
};
class SuperFruit : public Fruit {
public:
    SuperFruit(sf::Texture& tex, const sf::Vector2f& pos, int logicalType)
        : Fruit(tex, pos, logicalType) {
    }
    void onMatch(Board* board, int row, int col) override;
};























class Board{
  Board() {
        srand((time(0)));


        if (!textures[0].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Sprite Apple.png")) cerr << "Failed to load textures[0]\n";
        if (!textures[1].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Sprite Orange.png")) cerr << "Failed to load textures[1]\n";
        if (!textures[2].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Sprite Banana.png")) cerr << "Failed to load textures[2]\n";
        if (!textures[3].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Sprite Watermelon.png")) cerr << "Failed to load textures[3]\n";
        if (!textures[4].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Sprite Grape.png")) cerr << "Failed to load textures[4]\n";
        if (!textures[5].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Bomba.png")) cerr << "Failed to load textures[5]\n";
        if (!textures[6].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\cubo hielo.png")) cerr << "Failed to load textures[5]\n";
        if (!textures[7].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\manzanaD1.png")) cerr << "Failed to load textures[5]\n";
        if (!textures[8].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Naranja de oro12.png")) cerr << "Failed to load textures[5]\n";
        if (!textures[9].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Banano dorado12.png")) cerr << "Failed to load textures[5]\n";
        if (!textures[10].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\sandia dorada12.png")) cerr << "Failed to load textures[5]\n";
        if (!textures[11].loadFromFile("C:\\Joshua\\Proyecto Primer Avance\\Assets\\Unvas doradas12.png")) cerr << "Failed to load textures[5]\n";


        initObjectiveForLevel(level);

        for (int r = 0; r < SIZE; ++r)
            for (int c = 0; c < SIZE; ++c) {
                matrix[r][c] = nullptr;
                marked[r][c] = comboMarked[r][c] = forcedBreak[r][c] = false;
            }

        // Ahora: inicializar usando probabilidades del nivel actual (aquí el hielo sí puede aparecer)
        for (int r = 0; r < SIZE; ++r) {
            for (int c = 0; c < SIZE; ++c) {
                sf::Vector2f center = cellCenter(r, c);
                int roll = rand() % 100;
                if (roll < initBombChance[level]) {
                    matrix[r][c] = new BombFruit(textures[BOMB_INDEX], center, BOMB_INDEX);
                }
                else if (roll < initBombChance[level] + initIceChance[level]) {
                    matrix[r][c] = new IceFruit(textures[ICE_INDEX], center, ICE_INDEX);
                }
                else {
                    int t = rand() % NUM_NORMAL;
                    matrix[r][c] = new NormalFruit(textures[t], center, t);
                }
            }
        }

        bool cont = true;
        while (cont) {
            if (clearCombosOnce(false)) {
                applyGravityInstantForInit();
            }
            else cont = false;
        }
    }



     void initObjectiveForLevel(int lvl) {
        objectiveKind = 0;
        objectiveTarget = 0;
        objectiveProgress = 0;
        objectiveTargetFruit = -1;
        if (lvl == 1) {
            objectiveKind = 1;
            objectiveTarget = 10;
            objectiveTargetFruit = rand() % NUM_NORMAL;
        }
        else if (lvl == 2) {
            objectiveKind = 2;
            objectiveTarget = 3;
        }
        else if (lvl == 3) {
            objectiveKind = 3;
            objectiveTarget = 200;
            objectiveProgress = score; // starts at current score
        }
    }

       void incrementObjectiveOnDelete(int fruitType) {
        if (objectiveKind == 1) {
            // solo contar si es un normal del tipo objetivo
            if (fruitType >= 0 && fruitType < NUM_NORMAL && fruitType == objectiveTargetFruit) {
                objectiveProgress++;
            }
        }
        else if (objectiveKind == 2) {
            if (fruitType == ICE_INDEX) objectiveProgress++;
        }
        else if (objectiveKind == 3) {
            // para objetivo de puntos, el progreso está ligado al score; lo actualizaremos fuera
        }
    }
    void setLevel(int lvl) {
        if (lvl < 1) lvl = 1;
        if (lvl > 3) lvl = 3;
        level = lvl;
        initObjectiveForLevel(level);
    }

    Fruit* createFruitByType(int logicalType, sf::Texture& tex, sf::Vector2f pixelCenter) {
        if (logicalType == BOMB_INDEX) return new BombFruit(tex, pixelCenter, logicalType);
        if (logicalType == ICE_INDEX) return new IceFruit(tex, pixelCenter, logicalType);
        return new NormalFruit(tex, pixelCenter, logicalType);
    }







     if (anyRemoval) {
                if (lastSwapR1 != -1) {
                    if (lastSwapR1 >= 0 && lastSwapR1 < SIZE && lastSwapC1 >= 0 && lastSwapC1 < SIZE) {
                        if (matrix[lastSwapR1][lastSwapC1] && matrix[lastSwapR1][lastSwapC1]->getType() == ICE_INDEX) {
                            markedLocal[lastSwapR1][lastSwapC1] = true;
                            comboLocal[lastSwapR1][lastSwapC1] = true;
                        }
                    }
                }
                if (lastSwapR2 != -1) {
                    if (lastSwapR2 >= 0 && lastSwapR2 < SIZE && lastSwapC2 >= 0 && lastSwapC2 < SIZE) {
                        if (matrix[lastSwapR2][lastSwapC2] && matrix[lastSwapR2][lastSwapC2]->getType() == ICE_INDEX) {
                            markedLocal[lastSwapR2][lastSwapC2] = true;
                            comboLocal[lastSwapR2][lastSwapC2] = true;

                        }
                    }
                }
            }
            if (anyRemoval) {
                for (int r = 0; r < SIZE; ++r) {
                    for (int c = 0; c < SIZE; ++c) {
                        marked[r][c] = markedLocal[r][c];
                        comboMarked[r][c] = comboLocal[r][c];
                        if (marked[r][c] && matrix[r][c]) {

                            matrix[r][c]->startPop(300.f, MARK_SCALE);

                        }
                    }
                }
                removalPending = true;
                return true;
            }



              for (int r = 0; r < SIZE; ++r) {
                    for (int c = 0; c < SIZE; ++c) {
                        if (!marked[r][c] || !matrix[r][c]) continue;

                        bool isIce = (matrix[r][c]->getType() == ICE_INDEX);
                        if (isIce && !comboMarked[r][c] && !forcedBreak[r][c]) {
                            continue;
                        }

                        // Si esta celda es la posición objetivo de la SUPER y hay un super pendiente:
                        if (super >= 0 && super <= 4 && r == superR && c == superC) {
                            delete matrix[r][c];
                            matrix[r][c] = new SuperFruit(textures[7 + super], cellCenter(r, c), super);

                            // opcional: ajustar visual (por ejemplo, destacar)
                           // matrix[r][c]->resetVisual()
                            super = -1;
                            superR = superC = -1;
                            continue;
                        }

                        // Caso normal: actualizar objetivo y eliminar la fruta
                        incrementObjectiveOnDelete(matrix[r][c]->getType());

                        // eliminar y contar puntos
                        delete matrix[r][c];
                        matrix[r][c] = nullptr;
                        anyRemoval = true;
                        score += 10;

                        if (objectiveKind == 3) objectiveProgress = score;
                    }
                }






                 void applyGravityAndReplace() {
        if (gravityAnimating) return;

        Fruit* finalMatrix[SIZE][SIZE];
        for (int r = 0; r < SIZE; ++r) for (int c = 0; c < SIZE; ++c) finalMatrix[r][c] = nullptr;

        // compact columns downward and create new fruits for empty spots at top
        for (int c = 0; c < SIZE; ++c) {
            int writeRow = SIZE - 1;
            // move existing fruit pointers down
            for (int r = SIZE - 1; r >= 0; --r) {
                if (matrix[r][c] != nullptr) {
                    finalMatrix[writeRow][c] = matrix[r][c];
                    writeRow--;
                }
            }
            // create new fruit objects for rows 0..writeRow
            for (int r = writeRow; r >= 0; --r) {
                int roll = rand() % 100;
                sf::Vector2f dummy = { 0.f, 0.f };

                // Priorizar creación de "super" si hay uno pendiete (super == 0..4)

                if (roll < refillBombChance[level]) {
                    finalMatrix[r][c] = createFruitByType(BOMB_INDEX, textures[BOMB_INDEX], dummy);
                }
                else {
                    int t = rand() % NUM_NORMAL;
                    finalMatrix[r][c] = createFruitByType(t, textures[t], dummy);
                }
            }

        }

        // preserve previous pointers to decide which fruits are new
        Fruit* prevMatrix[SIZE][SIZE];
        for (int r = 0; r < SIZE; ++r) for (int c = 0; c < SIZE; ++c) prevMatrix[r][c] = matrix[r][c];

        // reassign matrix to final pointers
        for (int r = 0; r < SIZE; ++r) for (int c = 0; c < SIZE; ++c) matrix[r][c] = finalMatrix[r][c];

        // For each column, from bottom to top, decide initial position and start move
        for (int c = 0; c < SIZE; ++c) {
            // build list of prev pointers in this column (any order)
            vector<Fruit*> prevList;
            for (int r = 0; r < SIZE; ++r) {
                if (prevMatrix[r][c] != nullptr) prevList.push_back(prevMatrix[r][c]);
            }

            // We'll match bottom-up: for each target row from bottom to top, if that pointer is equal to one of prevList -> reused
            // else it's new
            int newAboveCount = 0;
            // iterate bottom-up
            for (int r = SIZE - 1; r >= 0; --r) {
                Fruit* f = matrix[r][c];
                if (!f) continue;
                sf::Vector2f target = cellCenter(r, c);

                bool existedBefore = false;
                // search prevList for pointer equality
                for (Fruit* pf : prevList) if (pf == f) { existedBefore = true; break; }

                if (existedBefore) {
                    // initial = its current sprite pos (where it was before), then move to target
                    sf::Vector2f init = f->getPixelPosition();
                    // start movement
                    f->startMoveTo(target.x, target.y, gravityDurationMs);
                    // remove this pointer from prevList so not reused again
                    for (auto it = prevList.begin(); it != prevList.end(); ++it) {
                        if (*it == f) { prevList.erase(it); break; }
                    }
                }
                else {
                    // new fruit: place above grid; stagger by newAboveCount to create stacked spawn
                    float initX = target.x;
                    float initY = originY - (newAboveCount + 1) * cellH + cellH / 2.f;
                    f->setPixelPosition(initX, initY);
                    f->startMoveTo(target.x, target.y, gravityDurationMs);
                    newAboveCount++;
                }
            }
        }

        gravityAnimating = true;
    }






     void applyGravityInstantForInit() {
        for (int c = 0; c < SIZE; ++c) {
            int writeRow = SIZE - 1;
            for (int r = SIZE - 1; r >= 0; --r) {
                if (matrix[r][c] != nullptr) {
                    if (writeRow != r) {
                        matrix[writeRow][c] = matrix[r][c];
                        matrix[r][c] = nullptr;
                    }
                    writeRow--;
                }
            }
            for (int r = writeRow; r >= 0; --r) {
                int roll = rand() % 100;
                sf::Vector2f center = cellCenter(r, c);
                if (roll < initBombChance[level]) matrix[r][c] = createFruitByType(BOMB_INDEX, textures[BOMB_INDEX], center);
                else if (roll < initBombChance[level] + initIceChance[level]) matrix[r][c] = createFruitByType(ICE_INDEX, textures[ICE_INDEX], center);
                else {
                    int t = rand() % NUM_NORMAL;
                    matrix[r][c] = createFruitByType(t, textures[t], center);
                }
            }


        }

        for (int r = 0; r < SIZE; ++r)
            for (int c = 0; c < SIZE; ++c)
                if (matrix[r][c]) {
                    sf::Vector2f center = cellCenter(r, c);
                    matrix[r][c]->setPixelPosition(center.x, center.y);
                }
    }





     void updateAnimations() {
        float deltaMs = animClock.restart().asMilliseconds();  // Como está ahora
        bool anyMoving = false;

        for (int r = 0; r < SIZE; ++r) {
            for (int c = 0; c < SIZE; ++c) {
                if (matrix[r][c]) {
                    matrix[r][c]->updateMove();  // Actualiza movimientos
                    if (matrix[r][c]->isMoving()) anyMoving = true;

                    if (matrix[r][c]->isPopActive()) {
                        bool finished = matrix[r][c]->updatePop(deltaMs);  // Pasa deltaMs
                        if (finished) {
                            // Código existente para manejar el final de la animación
                            matrix[r][c]->onMatch(this, r, c);
                            markCellForRemoval(r, c, false);
                            startCleaning(true);
                        }
                    }
                }
            }
        }

        if (!anyMoving) {
            if (gravityAnimating) gravityAnimating = false;
            if (swapAnimating) {
                swapAnimating = false;
                if (pendingSwapCleaning) {
                    pendingSwapCleaning = false;
                    startCleaning(true);
                }
            }
        }
    }


      void selectOrSwap(int row, int col) {
        if (row < 0 || row >= SIZE || col < 0 || col >= SIZE) return;
        if (!matrix[row][col]) return;

        if (selectedRow == -1) {
            BombFruit* asBomb = dynamic_cast<BombFruit*>(matrix[row][col]);
            if (asBomb != nullptr) {

                matrix[row][col]->startPop(300.f, MARK_SCALE);

                removalPending = true;
                startCleaning(true);

                for (int dr = -1; dr <= 1; ++dr) {
                    for (int dc = -1; dc <= 1; ++dc) {
                        int nr = row + dr, nc = col + dc;
                        if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && matrix[nr][nc]) {

                            matrix[nr][nc]->startPop(300.f, MARK_SCALE);
                        }
                    }
                }
                return;
            }
            selectedRow = row; selectedCol = col;
            matrix[selectedRow][selectedCol]->setScale(SELECT_SCALE, SELECT_SCALE);
            return;
        }
        // second click
        if (selectedRow == row && selectedCol == col) {
            if (matrix[selectedRow][selectedCol]) matrix[selectedRow][selectedCol]->resetVisual();
            selectedRow = -1; selectedCol = -1;
            return;
        }

        if (matrix[selectedRow][selectedCol]) matrix[selectedRow][selectedCol]->resetVisual();

        swapCells(selectedRow, selectedCol, row, col);
        selectedRow = -1; selectedCol = -1;
    }


      string getObjectiveDescription() const {
        if (objectiveKind == 1) {
            if (objectiveTargetFruit == 0)
                return "Eliminar " + to_string(objectiveTarget) + " Manzanas";

            else if (objectiveTargetFruit == 1) {
                return "Eliminar " + to_string(objectiveTarget) + " Naranjas ";
            }
            else if (objectiveTargetFruit == 2) {
                return "Eliminar " + to_string(objectiveTarget) + " Bananas ";
            }
            else if (objectiveTargetFruit == 3) {
                return "Eliminar " + to_string(objectiveTarget) + " Sandías ";
            }
            else if (objectiveTargetFruit == 4) {
                return "Eliminar " + to_string(objectiveTarget) + " Uvas ";
            }
        }
        else if (objectiveKind == 2) {
            return "Eliminar " + to_string(objectiveTarget) + " hielos";
        }
        else if (objectiveKind == 3) {
            return "Conseguir " + to_string(objectiveTarget) + " puntos";
        }
        return "";
    }
    string getObjectiveProgressText() const {
        if (objectiveKind == 1 || objectiveKind == 2) {
            return to_string(objectiveProgress) + " / " + to_string(objectiveTarget);
        }
        else if (objectiveKind == 3) {
            return to_string(objectiveProgress) + " / " + to_string(objectiveTarget);
        }
        return "";
    }
    bool isObjectiveComplete() const {
        if (objectiveKind == 0) return true;
        if (objectiveKind == 3) return objectiveProgress >= objectiveTarget;
        return objectiveProgress >= objectiveTarget;
    }

    };












    class Game{
      void processEvents() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) window.close();

            if (event.type == sf::Event::Resized) {
                sf::View view(sf::FloatRect(0.f, 0.f, 800.f, 600.f));
                window.setView(view);
                if (menuTexture.getSize().x != 0 && menuTexture.getSize().y != 0) {
                    menuSprite.setScale(800.f / (float)menuTexture.getSize().x, 600.f / (float)menuTexture.getSize().y);
                }
                continue;
            }

            if (event.type == sf::Event::MouseButtonPressed && event.mouseButton.button == sf::Mouse::Left) {
                sf::Vector2f world = window.mapPixelToCoords(sf::Vector2i(event.mouseButton.x, event.mouseButton.y));

                if (state == GameState::MENU) {
                    if (playButton.getGlobalBounds().contains(world)) state = GameState::PLAYING;
                    if (easyB.getGlobalBounds().contains(world)) {
                        // EASY selected (solo visual y flag, no cambio de movimientos)
                        hardSelected = false;
                        easyB.setFillColor(sf::Color(100, 255, 100, 255));
                        hardB.setFillColor(sf::Color(200, 200, 200, 255));
                    }
                    if (hardB.getGlobalBounds().contains(world)) {
                        // HARD selected (solo visual y flag)
                        hardSelected = true;
                        hardB.setFillColor(sf::Color(100, 255, 100, 255));
                        easyB.setFillColor(sf::Color(200, 200, 200, 255));
                    }
                    if (outB.getGlobalBounds().contains(world)) window.close();
                }
                else if (state == GameState::PLAYING) {
                    if (board.isCleaning()) {
                    }
                    else {
                        if (!board.hasMoves()) continue;
                        int x = event.mouseButton.x;
                        int y = event.mouseButton.y;
                        auto rc = board.screenToCell(window, x, y);
                        int row = rc.first, col = rc.second;
                        if (row >= 0 && row < 8 && col >= 0 && col < 8) {
                            board.selectOrSwap(row, col);
                        }
                    }
                }
                else if (state == GameState::GAME_OVER) {
                    // Retry
                    if (retryButton.getGlobalBounds().contains(world)) {
                        board.resetBoard();
                        state = GameState::PLAYING;
                        return;
                    }
                    // Leave
                    if (leaveButton.getGlobalBounds().contains(world)) {
                        window.close();
                        return;
                    }
                    // Menu (vuelve a pantalla principal)
                    if (menuButton.getGlobalBounds().contains(world)) {
                        // volver a menu principal, reset level 1, marcar FACIL por defecto
                        board.setLevelPublic(1);
                        board.resetBoard();
                        state = GameState::MENU;
                        // set difficulty default = easy
                        hardSelected = false;
                        easyB.setFillColor(sf::Color(100, 255, 100, 255));
                        hardB.setFillColor(sf::Color(200, 200, 200, 255));
                        board.resetMoves(5);
                        return;
                    }
                    if (board.getLevel() < 3 && nextLevelButton.getGlobalBounds().contains(world)) {
                        bool objectiveComplete = board.isObjectiveComplete();
                        bool canAdvance = (!hardSelected) || objectiveComplete;
                        if (canAdvance) {
                            int newLevel = board.getLevel() + 1;
                            board.setLevelPublic(newLevel);
                            board.resetBoard();
                            state = GameState::PLAYING;
                            return;
                        }
                    }
                }
            }
        }
    }
    
    
    
    


    void update() {
        if (state == GameState::PLAYING) {
            board.updateAnimations();
            if (board.isGravityAnimating()) {
                board.updateAnimations();
            }
            else if (board.isCleaning()) {
                if (cleaningClock.getElapsedTime() >= cleaningDelay) {
                    board.stepCleaning();
                    cleaningClock.restart();
                }
            }
            if (!board.hasMoves() && board.isIdle()) {
                state = GameState::GAME_OVER;
            }
            scoreText.setString("PUNTUACIÓN: " + to_string(board.getScore()));
            movesText.setString("MOVIMIENTOS: " + to_string(board.getRemainingMoves()));

            levelText.setString("Nivel: " + to_string(board.getLevel()));
            levelText.setPosition(360.f, 10.f);
            levelText.setCharacterSize(25);
        }
    }






      void render() {
        window.clear(sf::Color::White);

        if (state == GameState::MENU) {
            if (menuTexture.getSize().x != 0 && menuTexture.getSize().y != 0) window.draw(menuSprite);
            window.draw(titleText);
            window.draw(playButton);
            window.draw(playButtonText);
            window.draw(dificulty);
            window.draw(easyB);
            window.draw(easy);
            window.draw(hardB);
            window.draw(hard);
            window.draw(outB);
            window.draw(outText);
        }
        else if (state == GameState::PLAYING) {
            if (menuTexture.getSize().x != 0 && menuTexture.getSize().y != 0) window.draw(menuSprite);
            if (backgroundTexture.getSize().x != 0 && backgroundTexture.getSize().y != 0) window.draw(backgroundSprite);
            board.draw(window);

            // draw texts
            window.draw(scoreText);
            window.draw(movesText);
            window.draw(levelText);

            // draw objective top-right
            sf::Text objTitle, objProgress;
            objTitle.setFont(font);
            objTitle.setCharacterSize(18);
            objTitle.setFillColor(sf::Color::Black);
            objTitle.setString("OBJETIVO:");
            objTitle.setPosition(650.f, 10.f);

            objProgress.setFont(font);
            objProgress.setCharacterSize(19);
            objProgress.setFillColor(sf::Color::Black);

            string desc = board.getObjectiveDescription();
            string prog = board.getObjectiveProgressText();

            objProgress.setString(" " + desc + "\n" + prog);

            objProgress.setPosition(605.f, 35.f);

            window.draw(objTitle);
            window.draw(objProgress);
        }
        else if (state == GameState::GAME_OVER) {
            if (menuTexture.getSize().x != 0 && menuTexture.getSize().y != 0) window.draw(menuSprite);

            sf::RectangleShape overlay(sf::Vector2f(800.f, 600.f));
            overlay.setFillColor(sf::Color(255, 255, 255, 200));
            overlay.setPosition(0.f, 0.f);
            window.draw(overlay);

            window.draw(gameOverText);
            window.draw(retryButton);
            window.draw(retryButtonText);
            window.draw(leaveButton);
            window.draw(leaveButtonText);

            // menú (siempre visible)
            window.draw(menuButton);
            window.draw(menuButtonText);

            bool objectiveComplete = board.isObjectiveComplete();
            bool objectiveExists = !board.getObjectiveDescription().empty();

            // Mostrar mensaje de objetivo cumplido/fallido
            sf::Text resultText;
            resultText.setFont(font);
            resultText.setCharacterSize(25);
            resultText.setFillColor(sf::Color::Black);
            if (objectiveExists) {
                if (objectiveComplete) {
                    resultText.setString("OBJETIVO CUMPLIDO");
                }
                else {
                    resultText.setString("OBJETIVO FALLIDO");
                }
            }
            else {
                resultText.setString("");
            }
            resultText.setPosition(110.f, 140.f);
            window.draw(resultText);
            if (board.getLevel() < 3) {
                if (!hardSelected) {
                    // easy: mostrar y permitir avanzar
                    window.draw(nextLevelButton);
                    window.draw(nextLevelText);
                }
                else {
                    // hard: mostrar solo si objetivo completado; si falló, NO mostrar
                    if (objectiveComplete) {
                        window.draw(nextLevelButton);
                        window.draw(nextLevelText);
                    }
                    // else no dibujar el botón
                }
            }
            // mostrar progreso del objetivo en pantalla final
            sf::Text objTitle;
            objTitle.setFont(font);
            objTitle.setCharacterSize(23);
            objTitle.setFillColor(sf::Color::Black);
            objTitle.setString("" + board.getObjectiveDescription());
            objTitle.setPosition(420.f, 140.f);
            window.draw(objTitle);

            sf::Text objProg;
            objProg.setFont(font);
            objProg.setCharacterSize(25);
            objProg.setFillColor(sf::Color::Black);
            objProg.setString("Obtuviste: " + board.getObjectiveProgressText());
            objProg.setPosition(313.f, 183.f);
            window.draw(objProg);

            sf::Text finalScore;
            finalScore.setFont(font);
            finalScore.setCharacterSize(25);
            finalScore.setString("Puntaje Final: " + to_string(board.getScore()));
            finalScore.setFillColor(sf::Color::Black);
            finalScore.setPosition(305.f, 90.f);
            window.draw(finalScore);
        }
        window.display();
    }
    
    
    
    
    };












